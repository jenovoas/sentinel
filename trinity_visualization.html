<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Sentinel Trinity - Universal Map</title>
    <style>
        body { 
            margin: 0; 
            overflow: hidden; 
            background-color: #000; 
            font-family: 'Courier New', monospace; 
        }
        #canvas-container { 
            width: 100vw; 
            height: 100vh; 
        }
        #overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #d4af37; /* Gold */
            pointer-events: none;
            text-shadow: 0 0 10px rgba(212, 175, 55, 0.5);
            z-index: 10;
        }
        h1 { 
            font-size: 1.2rem; 
            margin: 0; 
            letter-spacing: 2px; 
        }
        p { 
            font-size: 0.8rem; 
            opacity: 0.8; 
        }
        .layer-label {
            position: absolute;
            color: white;
            font-size: 0.8rem;
            pointer-events: none;
            opacity: 0.6;
            transition: opacity 0.3s;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #888;
            font-size: 0.7rem;
            pointer-events: none;
        }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
</head>
<body>
    <div id="overlay">
        <h1>THE SENTINEL TRINITY</h1>
        <p>Physics • Biology • Technology</p>
        <p style="font-size: 0.6rem; color: #aaa;">Drag to Rotate • Scroll to Zoom</p>
    </div>
    <div id="info">
        <p>Coherence: <span id="coherence">0.00</span></p>
        <p>State: <span id="state">THERMAL</span></p>
    </div>
    <div id="canvas-container"></div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- SCENE SETUP ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 0, 15);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x000000, 1);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- CONTROLS ---
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;

        // --- LIGHTS ---
        const ambientLight = new THREE.AmbientLight(0x404040, 0.5);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0x3399ff, 2, 50);
        pointLight1.position.set(10, 10, 10);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0xff3366, 2, 50);
        pointLight2.position.set(-10, -10, -10);
        scene.add(pointLight2);

        const pointLight3 = new THREE.PointLight(0xffd700, 1.5, 30);
        pointLight3.position.set(0, 0, 0);
        scene.add(pointLight3);

        // --- LAYER 1: PHYSICS (MERKABAH) ---
        const merkabahGroup = new THREE.Group();
        merkabahGroup.position.y = 8;

        // Upward Tetrahedron (MACRO - Blue)
        const tetraGeometry = new THREE.TetrahedronGeometry(2);
        const macroMaterial = new THREE.MeshPhongMaterial({
            color: 0x3399ff,
            transparent: true,
            opacity: 0.6,
            emissive: 0x3399ff,
            emissiveIntensity: 0.3,
            wireframe: false
        });
        const macroTetra = new THREE.Mesh(tetraGeometry, macroMaterial);
        merkabahGroup.add(macroTetra);

        // Downward Tetrahedron (MICRO - Red)
        const microMaterial = new THREE.MeshPhongMaterial({
            color: 0xff3366,
            transparent: true,
            opacity: 0.6,
            emissive: 0xff3366,
            emissiveIntensity: 0.3,
            wireframe: false
        });
        const microTetra = new THREE.Mesh(tetraGeometry, microMaterial);
        microTetra.rotation.y = Math.PI;
        merkabahGroup.add(microTetra);

        // Coherence Sphere (Gold)
        const sphereGeometry = new THREE.SphereGeometry(0.8, 32, 32);
        const sphereMaterial = new THREE.MeshPhongMaterial({
            color: 0xffd700,
            emissive: 0xffd700,
            emissiveIntensity: 0.5,
            transparent: true,
            opacity: 0.8
        });
        const coherenceSphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
        merkabahGroup.add(coherenceSphere);

        scene.add(merkabahGroup);

        // --- LAYER 2: BIOLOGY (NEURAL HIERARCHY) ---
        const hierarchyGroup = new THREE.Group();
        hierarchyGroup.position.y = 0;

        const levels = 7;
        const levelHeight = 1.5;
        const levelRadius = 3;

        for (let i = 0; i < levels; i++) {
            const y = (i - levels / 2) * levelHeight;
            
            // Alpha node (blue)
            const alphaGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const alphaMaterial = new THREE.MeshPhongMaterial({
                color: 0x3399ff,
                emissive: 0x3399ff,
                emissiveIntensity: 0.2
            });
            const alphaNode = new THREE.Mesh(alphaGeometry, alphaMaterial);
            alphaNode.position.set(-levelRadius, y, 0);
            hierarchyGroup.add(alphaNode);

            // Beta node (red)
            const betaMaterial = new THREE.MeshPhongMaterial({
                color: 0xff3366,
                emissive: 0xff3366,
                emissiveIntensity: 0.2
            });
            const betaNode = new THREE.Mesh(alphaGeometry, betaMaterial);
            betaNode.position.set(levelRadius, y, 0);
            hierarchyGroup.add(betaNode);

            // Connection line
            const lineMaterial = new THREE.LineBasicMaterial({ 
                color: 0xffd700, 
                opacity: 0.3, 
                transparent: true 
            });
            const lineGeometry = new THREE.BufferGeometry().setFromPoints([
                new THREE.Vector3(-levelRadius, y, 0),
                new THREE.Vector3(levelRadius, y, 0)
            ]);
            const line = new THREE.Line(lineGeometry, lineMaterial);
            hierarchyGroup.add(line);
        }

        scene.add(hierarchyGroup);

        // --- LAYER 3: TECHNOLOGY (FLOWER OF LIFE) ---
        const flowerGroup = new THREE.Group();
        flowerGroup.position.y = -8;

        const circleRadius = 1.5;
        const circlePositions = [
            { x: 0, z: 0 },
            { x: circleRadius * 1.5, z: 0 },
            { x: -circleRadius * 1.5, z: 0 },
            { x: circleRadius * 0.75, z: circleRadius * 1.3 },
            { x: -circleRadius * 0.75, z: circleRadius * 1.3 },
            { x: circleRadius * 0.75, z: -circleRadius * 1.3 },
            { x: -circleRadius * 0.75, z: -circleRadius * 1.3 }
        ];

        circlePositions.forEach((pos, index) => {
            const torusGeometry = new THREE.TorusGeometry(circleRadius, 0.1, 16, 100);
            const torusMaterial = new THREE.MeshPhongMaterial({
                color: 0x33ff99,
                emissive: 0x33ff99,
                emissiveIntensity: 0.2,
                transparent: true,
                opacity: 0.5
            });
            const torus = new THREE.Mesh(torusGeometry, torusMaterial);
            torus.position.set(pos.x, 0, pos.z);
            torus.rotation.x = Math.PI / 2;
            flowerGroup.add(torus);
        });

        scene.add(flowerGroup);

        // --- CONNECTING LINES (GOLDEN SPIRAL) ---
        const spiralMaterial = new THREE.LineBasicMaterial({ 
            color: 0xffd700, 
            opacity: 0.4, 
            transparent: true 
        });

        // Connect Merkabah to Hierarchy
        const line1Geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, 8, 0),
            new THREE.Vector3(0, 4, 0)
        ]);
        const line1 = new THREE.Line(line1Geometry, spiralMaterial);
        scene.add(line1);

        // Connect Hierarchy to Flower
        const line2Geometry = new THREE.BufferGeometry().setFromPoints([
            new THREE.Vector3(0, -4, 0),
            new THREE.Vector3(0, -8, 0)
        ]);
        const line2 = new THREE.Line(line2Geometry, spiralMaterial);
        scene.add(line2);

        // --- PARTICLE FIELD ---
        const particleCount = 1000;
        const particlesGeometry = new THREE.BufferGeometry();
        const particlePositions = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount * 3; i++) {
            particlePositions[i] = (Math.random() - 0.5) * 50;
        }

        particlesGeometry.setAttribute('position', new THREE.BufferAttribute(particlePositions, 3));
        const particlesMaterial = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.05,
            transparent: true,
            opacity: 0.6
        });
        const particles = new THREE.Points(particlesGeometry, particlesMaterial);
        scene.add(particles);

        // --- ANIMATION STATE ---
        let coherence = 0;
        let coherenceDirection = 1;

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            // Update coherence (simulate)
            coherence += 0.005 * coherenceDirection;
            if (coherence >= 1 || coherence <= 0) {
                coherenceDirection *= -1;
            }

            // Update state
            let state = 'THERMAL';
            let stateColor = 0xff3366;
            if (coherence >= 0.95) {
                state = 'MERKABAH';
                stateColor = 0xffd700;
            } else if (coherence >= 0.75) {
                state = 'RESONANT';
                stateColor = 0x33ff99;
            } else if (coherence >= 0.50) {
                state = 'SYNCING';
                stateColor = 0xffcc33;
            }

            // Update UI
            document.getElementById('coherence').textContent = coherence.toFixed(2);
            document.getElementById('state').textContent = state;
            document.getElementById('state').style.color = '#' + stateColor.toString(16).padStart(6, '0');

            // Rotate Merkabah
            macroTetra.rotation.y += 0.01 * coherence;
            microTetra.rotation.y -= 0.01 * coherence;

            // Pulse coherence sphere
            const scale = 1 + Math.sin(Date.now() * 0.001) * 0.1;
            coherenceSphere.scale.setScalar(scale);
            sphereMaterial.color.setHex(stateColor);
            sphereMaterial.emissive.setHex(stateColor);

            // Pulse hierarchy nodes
            hierarchyGroup.children.forEach((child, index) => {
                if (child instanceof THREE.Mesh) {
                    const pulse = Math.sin(Date.now() * 0.001 + index * 0.5) * 0.1 + 1;
                    child.scale.setScalar(pulse);
                }
            });

            // Rotate flower
            flowerGroup.rotation.y += 0.002;

            // Rotate particles slowly
            particles.rotation.y += 0.0005;

            controls.update();
            renderer.render(scene, camera);
        }

        animate();

        // --- WINDOW RESIZE ---
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
